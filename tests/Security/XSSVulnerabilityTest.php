<?php
/**
 * Security Tests: XSS Vulnerability Detection.
 *
 * Scans plugin files for Cross-Site Scripting (XSS) vulnerabilities.
 *
 * @package Trotibike\EwheelImporter\Tests\Security
 */

namespace Trotibike\EwheelImporter\Tests\Security;

/**
 * Test case for detecting XSS vulnerabilities.
 */
class XSSVulnerabilityTest extends SecurityTestCase {

    /**
     * XSS vulnerability patterns.
     *
     * @var array<string, string>
     */
    private array $xss_patterns = [
        // Direct echo of user input
        'echo_get'                => '/echo\s+\$_GET\s*\[/i',
        'echo_post'               => '/echo\s+\$_POST\s*\[/i',
        'echo_request'            => '/echo\s+\$_REQUEST\s*\[/i',
        'echo_server'             => '/echo\s+\$_SERVER\s*\[\s*[\'"](?:REQUEST_URI|QUERY_STRING|HTTP_REFERER|PHP_SELF)/i',

        // Print of user input
        'print_get'               => '/print\s+\$_GET\s*\[/i',
        'print_post'              => '/print\s+\$_POST\s*\[/i',
        'print_request'           => '/print\s+\$_REQUEST\s*\[/i',

        // PHP short echo without escaping
        'short_echo_get'          => '/\<\?=\s*\$_GET/i',
        'short_echo_post'         => '/\<\?=\s*\$_POST/i',
        'short_echo_request'      => '/\<\?=\s*\$_REQUEST/i',

        // Unescaped JSON output
        'json_unescaped'          => '/json_encode\s*\(\s*\$_(?:GET|POST|REQUEST)/i',
    ];

    /**
     * Required escaping functions for different contexts.
     *
     * @var array<string, array<string>>
     */
    private array $escaping_contexts = [
        'html'       => [ 'esc_html', 'esc_html__', 'esc_html_e', 'wp_kses', 'wp_kses_post' ],
        'attribute'  => [ 'esc_attr', 'esc_attr__', 'esc_attr_e' ],
        'url'        => [ 'esc_url', 'esc_url_raw' ],
        'javascript' => [ 'esc_js', 'wp_json_encode' ],
        'textarea'   => [ 'esc_textarea' ],
    ];

    /**
     * Test that no files directly echo $_GET.
     */
    public function test_no_direct_echo_get(): void {
        $violations = $this->scan_for_pattern( $this->xss_patterns['echo_get'] );

        $this->assertEmpty(
            $violations,
            'Found direct echo of $_GET (XSS vulnerability): ' . $this->format_violations( $violations )
        );
    }

    /**
     * Test that no files directly echo $_POST.
     */
    public function test_no_direct_echo_post(): void {
        $violations = $this->scan_for_pattern( $this->xss_patterns['echo_post'] );

        $this->assertEmpty(
            $violations,
            'Found direct echo of $_POST (XSS vulnerability): ' . $this->format_violations( $violations )
        );
    }

    /**
     * Test that no files directly echo $_REQUEST.
     */
    public function test_no_direct_echo_request(): void {
        $violations = $this->scan_for_pattern( $this->xss_patterns['echo_request'] );

        $this->assertEmpty(
            $violations,
            'Found direct echo of $_REQUEST (XSS vulnerability): ' . $this->format_violations( $violations )
        );
    }

    /**
     * Test that no files echo dangerous $_SERVER variables.
     */
    public function test_no_direct_echo_server(): void {
        $violations = $this->scan_for_pattern( $this->xss_patterns['echo_server'] );

        $this->assertEmpty(
            $violations,
            'Found direct echo of $_SERVER (XSS vulnerability): ' . $this->format_violations( $violations )
        );
    }

    /**
     * Test that no files use short echo tags with user input.
     */
    public function test_no_short_echo_user_input(): void {
        $violations = array_merge(
            $this->scan_for_pattern( $this->xss_patterns['short_echo_get'] ),
            $this->scan_for_pattern( $this->xss_patterns['short_echo_post'] ),
            $this->scan_for_pattern( $this->xss_patterns['short_echo_request'] )
        );

        $this->assertEmpty(
            $violations,
            'Found short echo tag with user input: ' . $this->format_violations( $violations )
        );
    }

    /**
     * Test that JSON encoding of user input is properly escaped.
     */
    public function test_no_unescaped_json_user_input(): void {
        $violations = $this->scan_for_pattern( $this->xss_patterns['json_unescaped'] );

        $this->assertEmpty(
            $violations,
            'Found unescaped JSON with user input: ' . $this->format_violations( $violations )
        );
    }

    /**
     * Test that all echo statements in template files use escaping.
     */
    public function test_template_files_use_escaping(): void {
        $violations = [];

        // Specifically check admin template
        $template_files = [
            $this->plugin_root . '/includes/Admin/admin-page-template.php',
        ];

        foreach ( $template_files as $file ) {
            if ( ! file_exists( $file ) ) {
                continue;
            }

            $content = file_get_contents( $file );
            $lines   = explode( "\n", $content );

            foreach ( $lines as $line_num => $line ) {
                // Skip lines with proper escaping
                if ( $this->line_has_escaping( $line ) ) {
                    continue;
                }

                // Check for echo/print with variables
                if ( preg_match( '/<\?(?:php)?\s*echo\s+\$(?!this)/', $line ) ||
                     preg_match( '/<\?=\s*\$/', $line ) ) {
                    $violations[] = [
                        'file'  => $this->get_relative_path( $file ),
                        'line'  => $line_num + 1,
                        'match' => trim( substr( $line, 0, 80 ) ),
                    ];
                }
            }
        }

        $this->assertEmpty(
            $violations,
            'Template files with potentially unescaped output: ' . $this->format_violations( $violations )
        );
    }

    /**
     * Test comprehensive XSS scan.
     */
    public function test_comprehensive_xss_scan(): void {
        $all_violations = [];

        foreach ( $this->xss_patterns as $name => $pattern ) {
            $violations = $this->scan_for_pattern( $pattern );
            if ( ! empty( $violations ) ) {
                $all_violations[ $name ] = $violations;
            }
        }

        $this->assertEmpty(
            $all_violations,
            'Found potential XSS vulnerabilities: ' . print_r( $all_violations, true )
        );
    }

    /**
     * Check if a line has escaping functions.
     *
     * @param string $line Line content.
     * @return bool
     */
    private function line_has_escaping( string $line ): bool {
        $all_escape_functions = [];
        foreach ( $this->escaping_contexts as $functions ) {
            $all_escape_functions = array_merge( $all_escape_functions, $functions );
        }

        foreach ( $all_escape_functions as $func ) {
            if ( strpos( $line, $func ) !== false ) {
                return true;
            }
        }

        // Also check for common safe patterns
        $safe_patterns = [ 'htmlspecialchars', 'htmlentities', 'intval', 'absint' ];
        foreach ( $safe_patterns as $pattern ) {
            if ( strpos( $line, $pattern ) !== false ) {
                return true;
            }
        }

        return false;
    }
}
